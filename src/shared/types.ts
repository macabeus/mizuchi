/**
 * Plugin Architecture Types
 *
 * The plugin system provides a modular way to handle the decompilation pipeline.
 */
import type { ClaudeRunnerResult } from '~/plugins/claude-runner/claude-runner-plugin.js';
import type { CompilerResult } from '~/plugins/compiler/compiler-plugin.js';
import type { M2cPluginResult } from '~/plugins/m2c/m2c-plugin.js';
import type { ObjdiffResult } from '~/plugins/objdiff/objdiff-plugin.js';
import type { DecompPermuterResult } from '~/shared/decomp-permuter.js';

import type { PipelineConfig } from './config.js';

/**
 * Mapping of plugin IDs to their result types
 */
export type PluginResultMap = {
  'claude-runner': PluginResult<ClaudeRunnerResult>;
  compiler: PluginResult<CompilerResult>;
  'decomp-permuter': PluginResult<DecompPermuterResult>;
  m2c: PluginResult<M2cPluginResult>;
  objdiff: PluginResult<ObjdiffResult>;
};

/**
 * Result status for a plugin execution
 */
export type PluginStatus = 'success' | 'failure' | 'skipped';

/**
 * Base result interface for all plugins
 */
export interface PluginResult<TPluginResult> {
  /** Unique identifier for the plugin that produced this result */
  pluginId: string;
  /** Human-readable plugin name */
  pluginName: string;
  /** Status of the execution */
  status: PluginStatus;
  /** Duration of execution in milliseconds */
  durationMs: number;
  /** Error message if status is 'failure' */
  error?: string;
  /** Human-readable output/logs from the plugin */
  output?: string;
  /** Any additional data specific to the plugin */
  data?: TPluginResult;
  /** Report sections generated by the plugin */
  sections?: PluginReportSection[];
}

/**
 * Context passed between plugins in the pipeline
 */
export interface PipelineContext {
  /** The current prompt being processed */
  promptPath?: string;
  /** Content of the prompt */
  promptContent?: string;
  /** Name of the function being decompiled */
  functionName: string;
  /** GAS-formatted assembly for the function */
  asm: string;
  /** Generated C code from Claude */
  generatedCode?: string;
  /** Path to the compiled object file */
  compiledObjectPath?: string;
  /** Path to the target object file for comparison */
  targetObjectPath?: string;
  /** Context file content (from getContextScript stdout) */
  contextContent?: string;
  /** Path to temp file containing context content */
  contextFilePath?: string;
  /** Current attempt number (1-indexed) */
  attemptNumber: number;
  /** Maximum retries allowed */
  maxRetries: number;
  /** Previous attempt results for feedback - maps plugin IDs to their results for each attempt */
  previousAttempts?: Array<Partial<PluginResultMap>>;
  /** Configuration options */
  config: PipelineConfig;
  /** Context from m2c programmatic-flow phase, available to Claude Runner on first attempt */
  m2cContext?: {
    generatedCode: string;
    compilationError?: string;
    objdiffOutput?: string;
  };
}

/**
 * Tool use content block in a chat message
 */
export interface ToolUseBlock {
  type: 'tool_use';
  id: string;
  name: string;
  input: Record<string, unknown>;
}

/**
 * Tool result content block in a chat message
 */
export interface ToolResultBlock {
  type: 'tool_result';
  tool_use_id: string;
  content: string;
}

/**
 * Text content block in a chat message
 */
export interface TextBlock {
  type: 'text';
  text: string;
}

/**
 * Content block that can appear in chat messages
 */
export type ContentBlock = TextBlock | ToolUseBlock | ToolResultBlock;

/**
 * Chat message in a conversation
 */
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string | ContentBlock[];
}

/**
 * Report data that a plugin can contribute to the benchmark report
 */
export type PluginReportSection =
  | {
      type: 'code';
      title: string;
      language: 'c' | 'markdown' | 'json' | 'text' | 'diff';
      code: string;
    }
  | {
      type: 'message';
      title: string;
      message: string;
    }
  | {
      type: 'chat';
      title: string;
      messages: ChatMessage[];
    };

/**
 * Context provided to background plugins when deciding whether to spawn
 */
export interface BackgroundSpawnContext {
  /** Current attempt number */
  attemptNumber: number;
  /** Whether there will be more attempts after this one */
  willRetry: boolean;
  /** The pipeline context after this attempt completed */
  context: PipelineContext;
  /** Plugin results from this attempt */
  attemptResults: PluginResult<any>[];
}

/**
 * Metadata attached to background task results by the coordinator
 */
export interface TaskMetadata {
  taskId: string;
  durationMs: number;
  triggeredByAttempt: number;
  startTimestamp: string;
}

/**
 * Interface for plugins that support background execution.
 *
 * A plugin can run both in the sequential chain (via Plugin.execute()) and
 * in the background (via this capability). The coordinator calls shouldSpawn()
 * after each attempt and, if the plugin returns a config, spawns a background
 * task via run().
 */
export interface BackgroundCapability<TConfig = unknown, TResult = unknown> {
  /** Decide whether to spawn a background task. Return config to spawn, or null to skip. */
  shouldSpawn(context: BackgroundSpawnContext): TConfig | null;
  /** Run the background task. Must respect the abort signal. */
  run(config: TConfig, signal: AbortSignal): Promise<TResult>;
  /** Check if a result constitutes success (should stop the pipeline). */
  isSuccess(result: TResult): boolean;
  /** Convert plugin-specific result to the generic BackgroundTaskResult. */
  toBackgroundTaskResult(result: TResult, metadata: TaskMetadata): BackgroundTaskResult;
  /** Reset state between prompts (e.g., clear spawn tracking). */
  reset?(): void;
}

/**
 * Plugin interface that all plugins must implement
 */
export interface Plugin<TPluginResult> {
  /** Unique identifier for this plugin */
  readonly id: string;
  /** Human-readable name */
  readonly name: string;
  /** Description of what this plugin does */
  readonly description: string;

  /**
   * Execute the plugin with the given context
   * @param context Current pipeline context
   * @returns Plugin result and optionally updated context
   */
  execute(context: PipelineContext): Promise<{
    result: PluginResult<TPluginResult>;
    context: PipelineContext;
  }>;

  /**
   * Called before retry to prepare context (e.g., add feedback)
   * @param context Current context
   * @param previousAttempts Results from previous attempts, mapping plugin IDs to their results.
   *                         If a plugin was skipped during an attempt, it will not have an entry.
   * @returns Updated context for retry
   */
  prepareRetry?(context: PipelineContext, previousAttempts: Array<Partial<PluginResultMap>>): PipelineContext;

  /**
   * Generate report sections for this plugin's execution
   * @param result The result from execution
   * @param context The pipeline context used during execution
   * @returns Array of report sections to display
   */
  getReportSections?(result: PluginResult<TPluginResult>, context: PipelineContext): PluginReportSection[];

  /**
   * Receive an abort signal that fires when a background task succeeds.
   * Called by the PluginManager at the start of each prompt with a fresh signal.
   * Plugins that perform long-running foreground work (e.g., LLM queries) should
   * abort promptly when this signal fires.
   */
  setForegroundAbortSignal?(signal: AbortSignal): void;

  /**
   * Optional background execution capability.
   * When present, the BackgroundTaskCoordinator will call shouldSpawn() after each
   * attempt and run background tasks alongside the AI-powered flow.
   */
  background?: BackgroundCapability<any, any>;
}

/**
 * Result from a background task
 */
export type BackgroundTaskResult = {
  taskId: string;
  durationMs: number;
  triggeredByAttempt: number;
  startTimestamp: string;
} & (
  | {
      success: boolean;
      pluginId: 'decomp-permuter';
      data: DecompPermuterResult;
    }
  // Generic failure case for background tasks that failed to start
  | {
      success: false;
      pluginId: string;
      data: { error: string };
    }
);

/**
 * What found the match for a prompt
 */
export type MatchSource = string;

/**
 * Result of running the full pipeline for a single prompt
 */
export interface PipelineRunResult {
  promptPath: string;
  functionName: string;
  success: boolean;
  totalDurationMs: number;
  /** Result from setup-flow phase (e.g., get-context) */
  setupFlow: AttemptResult;
  /** Result from programmatic-flow (e.g., m2c), if one was configured */
  programmaticFlow?: AttemptResult;
  /** Results for every attempt from the AI-powered flow */
  attempts: AttemptResult[];
  /** Results from background permuter tasks */
  backgroundTasks?: BackgroundTaskResult[];
  /** What found the match (if successful) */
  matchSource?: MatchSource;
}

/**
 * Result of a single attempt through the pipeline
 */
export interface AttemptResult {
  attemptNumber: number;
  pluginResults: PluginResult<Record<string, unknown>>[];
  success: boolean;
  durationMs: number;
  /** ISO timestamp when the attempt started */
  startTimestamp: string;
}

/**
 * Full pipeline results with plugin details
 */
export interface PipelineResults {
  timestamp: string;
  config: PipelineConfig;
  results: PipelineRunResult[];
  summary: {
    totalPrompts: number;
    successfulPrompts: number;
    successRate: number;
    avgAttempts: number;
    totalDurationMs: number;
  };
}
