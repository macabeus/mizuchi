{
  "version": 1,
  "createdAt": "2026-01-11T22:58:51.144Z",
  "responses": [
    {
      "functionName": "TaskDestructor_CharacterSelect",
      "attemptNumber": 1,
      "generatedCode": "typedef struct {\n    /* 0x00 */ u8 filler0[0x3C];\n    /* 0x3C */ void *tiles;\n} CharacterSelect;\n\nvoid TaskDestructor_CharacterSelect(struct Task *t)\n{\n    CharacterSelect *cs = TASK_DATA(t);\n    VramFree(cs->tiles);\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    },
    {
      "functionName": "TaskDestructor_CharacterSelect",
      "attemptNumber": 2,
      "generatedCode": "typedef struct {\n    /* 0x00 */ void *tiles;\n} CharacterSelect;\n\n#define IWRAM_START 0x030000C4\n\n#define TASK_DATA(t) ((void *)((t)->data + IWRAM_START))\n\nvoid TaskDestructor_CharacterSelect(struct Task *t)\n{\n    CharacterSelect *cs = TASK_DATA(t);\n    VramFree(cs->tiles);\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    },
    {
      "functionName": "sub_809B770",
      "attemptNumber": 1,
      "generatedCode": "typedef struct {\n    u16 anim;\n    u8 variant;\n    u8 pad;\n    u32 tileCount;\n} SpriteConfig;\n\ntypedef struct {\n    u8 *unk0;\n    u8 *unk4;\n    u8 *unk8;\n    u8 *tiles;\n    s32 *unk10;\n    s32 *unk14;\n    Sprite sprites[6];\n    Sprite sprites2[6];\n} UnkStruct809B770;\n\nextern u8 gUnknown_080D8F18[];\nextern u8 gUnknown_080D9432[];\nextern u8 gUnknown_080D9438[];\nextern SpriteConfig *gUnknown_080D93D4[];\nextern SpriteConfig *gUnknown_080D93EC[];\n\nvoid sub_809B770(UnkStruct809B770 *unk)\n{\n    u8 idx;\n    u8 count;\n    SpriteConfig *config;\n    u8 *tiles;\n    u8 i;\n\n    idx = gUnknown_080D8F18[unk->unk0[0]];\n\n    if (unk->unk4[0] > 0x15) {\n        count = gUnknown_080D9438[idx];\n        config = gUnknown_080D93EC[idx];\n    } else {\n        count = gUnknown_080D9432[idx];\n        config = gUnknown_080D93D4[idx];\n    }\n\n    tiles = unk->tiles;\n\n    for (i = 0; i < count; i++) {\n        Sprite *s = &unk->sprites[i];\n\n        s->tiles = tiles;\n        tiles += config[i].tileCount * 32;\n\n        s->anim = config[i].anim;\n        s->variant = config[i].variant;\n        s->prevVariant = 0xFF;\n        s->x = unk->unk10[0] >> 8;\n        s->y = unk->unk14[0] >> 8;\n        s->oamFlags = 0x40;\n        s->animCursor = 0;\n        s->qAnimDelay = 0;\n        s->animSpeed = 0x10;\n        s->palId = 0;\n        s->frameFlags = 0;\n\n        UpdateSpriteAnimation(s);\n    }\n\n    if (unk->unk4[0] > 0x15) {\n        count = gUnknown_080D9438[5];\n        config = gUnknown_080D93EC[5];\n    } else {\n        count = gUnknown_080D9432[5];\n        config = gUnknown_080D93D4[5];\n    }\n\n    for (i = 0; i < count; i++) {\n        Sprite *s = &unk->sprites2[i];\n\n        s->tiles = tiles;\n        tiles += config[i].tileCount * 32;\n\n        s->anim = config[i].anim;\n        s->variant = config[i].variant;\n        s->prevVariant = 0xFF;\n        s->x = unk->unk10[0] >> 8;\n        s->y = unk->unk14[0] >> 8;\n        s->oamFlags = 0x40;\n        s->animCursor = 0;\n        s->qAnimDelay = 0;\n        s->animSpeed = 0x10;\n        s->palId = 0;\n        s->frameFlags = 0;\n\n        UpdateSpriteAnimation(s);\n    }\n\n    unk->tiles += 0xD40;\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    },
    {
      "functionName": "sub_809B770",
      "attemptNumber": 2,
      "generatedCode": "typedef struct {\n    u16 anim;\n    u8 variant;\n    u8 pad;\n    u32 tileCount;\n} SpriteConfig;\n\ntypedef struct {\n    u8 *unk0;\n    u8 *unk4;\n    u8 *unk8;\n    u8 *tiles;\n    s32 *unk10;\n    s32 *unk14;\n    Sprite sprites[6];\n    Sprite sprites2[6];\n} UnkStruct809B770;\n\nextern u8 gUnknown_080D8F18[];\nextern u8 gUnknown_080D9432[];\nextern u8 gUnknown_080D9438[];\nextern SpriteConfig *gUnknown_080D93D4[];\nextern SpriteConfig *gUnknown_080D93EC[];\n\nvoid sub_809B770(UnkStruct809B770 *unk)\n{\n    u8 idx;\n    u8 count;\n    SpriteConfig *config;\n    u8 *tiles;\n    u8 i;\n\n    idx = gUnknown_080D8F18[unk->unk0[0]];\n\n    if (unk->unk4[0] > 0x15) {\n        count = gUnknown_080D9438[idx];\n        config = gUnknown_080D93EC[idx];\n    } else {\n        count = gUnknown_080D9432[idx];\n        config = gUnknown_080D93D4[idx];\n    }\n\n    tiles = unk->tiles;\n\n    for (i = 0; i < count; i++) {\n        Sprite *s = &unk->sprites[i];\n\n        s->tiles = tiles;\n        tiles += config[i].tileCount * 32;\n\n        s->anim = config[i].anim;\n        s->variant = config[i].variant;\n        s->prevVariant = 0xFF;\n        s->x = unk->unk10[0] >> 8;\n        s->y = unk->unk14[0] >> 8;\n        s->oamFlags = 0x40;\n        s->animCursor = 0;\n        s->qAnimDelay = 0;\n        s->animSpeed = 0x10;\n        s->palId = 0;\n        s->frameFlags = 0;\n\n        UpdateSpriteAnimation(s);\n    }\n\n    if (unk->unk4[0] > 0x15) {\n        count = gUnknown_080D9438[5];\n        config = gUnknown_080D93EC[5];\n    } else {\n        count = gUnknown_080D9432[5];\n        config = gUnknown_080D93D4[5];\n    }\n\n    for (i = 0; i < count; i++) {\n        Sprite *s = (Sprite *)((u8 *)unk + 0x1A8 + i * 40);\n\n        s->tiles = tiles;\n        tiles += config[i].tileCount * 32;\n\n        s->anim = config[i].anim;\n        s->variant = config[i].variant;\n        s->prevVariant = 0xFF;\n        s->x = unk->unk10[0] >> 8;\n        s->y = unk->unk14[0] >> 8;\n        s->oamFlags = 0x40;\n        s->animCursor = 0;\n        s->qAnimDelay = 0;\n        s->animSpeed = 0x10;\n        s->palId = 0;\n        s->frameFlags = 0;\n\n        UpdateSpriteAnimation(s);\n    }\n\n    unk->tiles += 0xD40;\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    },
    {
      "functionName": "sub_805C510",
      "attemptNumber": 1,
      "generatedCode": "#include \"types.h\"\n\ntypedef struct {\n    s8 left;\n    s8 top;\n    s8 right;\n    s8 bottom;\n} HitboxRect;\n\ntypedef struct {\n    u8 pad0[0x10];\n    s16 x;\n    s16 y;\n    u8 pad14[0x18];\n    HitboxRect hitbox;\n} SecondarySprite;\n\ntypedef struct {\n    u8 pad0[0x16];\n    u16 unk16;\n    u8 pad18[0x8];\n    SecondarySprite secondary;\n} StageDataTask98_2;\n\nextern struct {\n    u8 pad0[0x98];\n    struct Task *task98;\n} gStageData;\n\n#define TASK_DATA(task) ((void*)((u8*)(task)->data + 0x03000000))\n\nbool32 sub_805C510(Sprite *s)\n{\n    struct Task *stageTask = gStageData.task98;\n    StageDataTask98_2 *stg98 = TASK_DATA(stageTask);\n    SecondarySprite *sec = &stg98->secondary;\n    bool32 result = FALSE;\n    u16 width1, height1;\n    u16 width2, height2;\n    s8 left1, right1, top1, bottom1;\n    s8 left2, right2, top2, bottom2;\n    s16 x1, y1, x2, y2;\n    s32 diff;\n\n    if (!(stg98->unk16 & 0x2)) {\n        return FALSE;\n    }\n\n    left1 = ((Hitbox*)((u8*)s + 0x24))->left;\n    right1 = ((Hitbox*)((u8*)s + 0x24))->right;\n    diff = left1 - right1;\n    if (diff < 0) {\n        diff = right1 - left1;\n    }\n    width1 = (u16)diff;\n\n    top1 = ((Hitbox*)((u8*)s + 0x24))->top;\n    bottom1 = ((Hitbox*)((u8*)s + 0x24))->bottom;\n    diff = top1 - bottom1;\n    if (diff < 0) {\n        diff = bottom1 - top1;\n    }\n    height1 = (u16)diff;\n\n    left2 = ((s8*)sec)[0x2C];\n    right2 = ((s8*)sec)[0x2E];\n    diff = left2 - right2;\n    if (diff < 0) {\n        diff = right2 - left2;\n    }\n    width2 = (u16)diff;\n\n    top2 = ((s8*)sec)[0x2D];\n    bottom2 = ((s8*)sec)[0x2F];\n    diff = top2 - bottom2;\n    if (diff < 0) {\n        diff = bottom2 - top2;\n    }\n    height2 = (u16)diff;\n\n    if (width1 == 0 && height1 == 0) {\n        return result;\n    }\n\n    x1 = s->x;\n    x2 = sec->x;\n\n    if (x1 <= x2) {\n        if (x1 + width1 >= x2) {\n            goto check_y;\n        }\n        if (x1 < x2) {\n            return result;\n        }\n    }\n\n    if (x2 + width2 < x1) {\n        return result;\n    }\n\ncheck_y:\n    y1 = s->y;\n    y2 = sec->y;\n\n    if (y1 <= y2) {\n        if (y1 + height1 >= y2) {\n            result = TRUE;\n            return result;\n        }\n        if (y1 < y2) {\n            return result;\n        }\n    }\n\n    if (y2 + height2 < y1) {\n        return result;\n    }\n\n    result = TRUE;\n    return result;\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    },
    {
      "functionName": "sub_805C510",
      "attemptNumber": 2,
      "generatedCode": "typedef unsigned char u8;\ntypedef signed char s8;\ntypedef unsigned short u16;\ntypedef signed short s16;\ntypedef unsigned int u32;\ntypedef signed int s32;\ntypedef u32 bool32;\n\ntypedef struct {\n    s8 left;\n    s8 top;\n    s8 right;\n    s8 bottom;\n} Hitbox;\n\ntypedef struct {\n    u8 *tiles;\n    u32 frameNum;\n    u32 frameFlags;\n    u16 anim;\n    u16 animCursor;\n    s16 x;\n    s16 y;\n    s16 oamFlags;\n    s16 qAnimDelay;\n    u16 prevAnim;\n    u8 variant;\n    u8 prevVariant;\n    u8 animSpeed;\n    u8 oamBaseIndex;\n    u8 numSubFrames;\n    u8 palId;\n    Hitbox hitboxes[1];\n} Sprite;\n\ntypedef struct {\n    u8 pad0[0x10];\n    s16 x;\n    s16 y;\n    u8 pad14[0x18];\n    s8 left;\n    s8 top;\n    s8 right;\n    s8 bottom;\n} SecondarySprite;\n\ntypedef struct {\n    u8 pad0[0x6];\n    u16 dataOffset;\n} Task;\n\ntypedef struct {\n    u8 pad0[0x16];\n    u16 unk16;\n} StageDataTask98Header;\n\nextern struct {\n    u8 pad0[0x98];\n    Task *task98;\n} gStageData;\n\nbool32 sub_805C510(Sprite *s)\n{\n    Task *stageTask = gStageData.task98;\n    u16 dataOffset = stageTask->dataOffset;\n    StageDataTask98Header *stg98 = (StageDataTask98Header *)((u8 *)dataOffset + 0x03000000);\n    SecondarySprite *sec = (SecondarySprite *)((u8 *)dataOffset + 0x03000020);\n    bool32 result = 0;\n    u16 width1, height1;\n    u16 width2, height2;\n    s8 left1, right1, top1, bottom1;\n    s8 left2, right2, top2, bottom2;\n    s16 x1, y1, x2, y2;\n    s32 diff;\n\n    if (!(stg98->unk16 & 0x2)) {\n        return 0;\n    }\n\n    left1 = s->hitboxes[0].left;\n    right1 = s->hitboxes[0].right;\n    diff = left1 - right1;\n    if (diff < 0) {\n        diff = right1 - left1;\n    }\n    width1 = (u16)diff;\n\n    top1 = s->hitboxes[0].top;\n    bottom1 = s->hitboxes[0].bottom;\n    diff = top1 - bottom1;\n    if (diff < 0) {\n        diff = bottom1 - top1;\n    }\n    height1 = (u16)diff;\n\n    left2 = sec->left;\n    right2 = sec->right;\n    diff = left2 - right2;\n    if (diff < 0) {\n        diff = right2 - left2;\n    }\n    width2 = (u16)diff;\n\n    top2 = sec->top;\n    bottom2 = sec->bottom;\n    diff = top2 - bottom2;\n    if (diff < 0) {\n        diff = bottom2 - top2;\n    }\n    height2 = (u16)diff;\n\n    if (width1 == 0 && height1 == 0) {\n        return result;\n    }\n\n    x1 = s->x;\n    x2 = sec->x;\n\n    if (x1 <= x2) {\n        if (x1 + width1 >= x2) {\n            goto check_y;\n        }\n        if (x1 < x2) {\n            return result;\n        }\n    }\n\n    if (x2 + (s16)width2 < x1) {\n        return result;\n    }\n\ncheck_y:\n    y1 = s->y;\n    y2 = sec->y;\n\n    if (y1 <= y2) {\n        if (y1 + height1 >= y2) {\n            result = 1;\n            return result;\n        }\n        if (y1 < y2) {\n            return result;\n        }\n    }\n\n    if (y2 + (s16)height2 < y1) {\n        return result;\n    }\n\n    result = 1;\n    return result;\n}",
      "timestamp": "2026-01-11T22:54:52.384Z"
    }
  ]
}
